# -*- coding: utf-8 -*-
"""2311001_Akanksha_Singh_Assignment6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lIw4n1v7hXGzchf5bG8JsvtYTm1yx8Xd
"""

import array
import random

# Helper function to create a random 1D array of the specified type and size
def create_random_array(data_type, size):
    if data_type == 'signed_char':
        return array.array('b', [random.randint(-128, 127) for _ in range(size)])
    elif data_type == 'unsigned_int':
        return array.array('I', [random.randint(0, 2**32 - 1) for _ in range(size)])
    elif data_type == 'float':
        return array.array('f', [random.uniform(0.0, 1.0) for _ in range(size)])
    elif data_type == 'double':
        return array.array('d', [random.uniform(0.0, 1.0) for _ in range(size)])
    else:
        raise ValueError("Unsupported data type")

# Function to traverse the array
def traverse(arr):
    for value in arr:
        print(value, end=' ')
    print()

# Function to insert a value at a random index
def insert_value(arr, value):
    index = random.randint(0, len(arr))
    arr.insert(index, value)

# Function to delete a value at a random index
def delete_value(arr):
    if len(arr) > 0:
        index = random.randint(0, len(arr) - 1)
        del arr[index]

# Function to search for a value in the array
def search_value(arr, value):
    try:
        index = arr.index(value)
        return index
    except ValueError:
        return None

# Function to update a value at a random index
def update_value(arr, new_value):
    if len(arr) > 0:
        index = random.randint(0, len(arr) - 1)
        arr[index] = new_value

# Create random arrays
signed_char_array = create_random_array('signed_char', 10)
unsigned_int_array = create_random_array('unsigned_int', 10)
float_array = create_random_array('float', 10)
double_array = create_random_array('double', 10)

# Traverse arrays
print("Signed Char Array:")
traverse(signed_char_array)

print("Unsigned Int Array:")
traverse(unsigned_int_array)

print("Float Array:")
traverse(float_array)

print("Double Array:")
traverse(double_array)

# Insertion
insert_value(signed_char_array, 42)
insert_value(unsigned_int_array, 12345)
insert_value(float_array, 3.14)
insert_value(double_array, 2.718)

# Deletion
delete_value(signed_char_array)
delete_value(unsigned_int_array)
delete_value(float_array)
delete_value(double_array)

# Search
search_val = 42
print(f"Search for {search_val} in Signed Char Array: Index {search_value(signed_char_array, search_val)}")

# Update
update_value(signed_char_array, 99)
update_value(unsigned_int_array, 54321)
update_value(float_array, 1.618)
update_value(double_array, 3.14159)

# Display updated arrays
print("Updated Signed Char Array:")
traverse(signed_char_array)

print("Updated Unsigned Int Array:")
traverse(unsigned_int_array)

print("Updated Float Array:")
traverse(float_array)

print("Updated Double Array:")
traverse(double_array)

import numpy as np
from datetime import datetime

# Step 1: Create a NumPy array with your birthdate (year, month, day)
birthdate = np.array([1990, 5, 15])  # Replace with your birthdate

# Step 2: Retrieve the year
birth_year = birthdate[0]

# Step 3: Replace the year with the current year
current_year = datetime.now().year
birthdate[0] = current_year

# Step 4: Create a NumPy array containing every 3rd number from 567 to 890
start_num = 567
end_num = 890
step = 3
num_array = np.arange(start_num, end_num + 1, step)

# Step 5: Find the 8th and 15th numbers in this array
eighth_number = num_array[7]  # Index 7 corresponds to the 8th number
fifteenth_number = num_array[14]  # Index 14 corresponds to the 15th number

# Display the results
print("Birthdate Array:", birthdate)
print("Birth Year:", birth_year)
print("Current Year:", current_year)
print("NumPy Array:", num_array)
print("8th Number in the Array:", eighth_number)
print("15th Number in the Array:", fifteenth_number)

import numpy as np

# (1) Create an array of 10 random integers, from 0-100
random_integers1 = np.random.randint(0, 101, 10)

# (2) Find the mean and standard deviation of these numbers
mean1 = np.mean(random_integers1)
std_dev1 = np.std(random_integers1)

# (3) Create another array of 10 random integers, from 0-100
random_integers2 = np.random.randint(0, 101, 10)

# (4) Create a new array whose elements are the average of those from each of the previous ones
average_array = (random_integers1 + random_integers2) / 2

# (5) Create an array of 10 random floats, from 0-100
random_floats = np.random.uniform(0, 100, 10)

# (6) Calculate the mean and standard deviation of the random floats
mean_floats = np.mean(random_floats)
std_dev_floats = np.std(random_floats)

# (7) Find the min and max values of the random floats
min_float = np.min(random_floats)
max_float = np.max(random_floats)

# Print the results
print("Random Integers Array 1:", random_integers1)
print("Mean of Random Integers Array 1:", mean1)
print("Standard Deviation of Random Integers Array 1:", std_dev1)

print("Random Integers Array 2:", random_integers2)

print("Average Array:", average_array)

print("Random Floats Array:", random_floats)
print("Mean of Random Floats Array:", mean_floats)
print("Standard Deviation of Random Floats Array:", std_dev_floats)
print("Min Value of Random Floats Array:", min_float)
print("Max Value of Random Floats Array:", max_float)

import numpy as np

# (1) Create an array of 20 random integers from 0 to 100
random_integers = np.random.randint(0, 101, 20)

# (2) Find the largest even number
even_numbers = random_integers[random_integers % 2 == 0]
largest_even = np.max(even_numbers)

# (3) Find the mean of the odd numbers
odd_numbers = random_integers[random_integers % 2 != 0]
mean_odd = np.mean(odd_numbers)

# (4) Create a NumPy array from the first and last odd numbers
first_odd = odd_numbers[0]
last_odd = odd_numbers[-1]
odd_array = np.array([first_odd, last_odd])

# (5) Create an array of 20 floats from 0-1,000
random_floats = np.random.uniform(0, 1000, 20)

# (6) Find the items that are less than the mean
mean_floats = np.mean(random_floats)
less_than_mean = random_floats[random_floats < mean_floats]

# (7) Find the items less than mean - std
std_floats = np.std(random_floats)
less_than_mean_minus_std = random_floats[random_floats < (mean_floats - std_floats)]

# Print the results
print("Random Integers Array:", random_integers)
print("Largest Even Number:", largest_even)
print("Mean of Odd Numbers:", mean_odd)
print("Array of First and Last Odd Numbers:", odd_array)
print("Random Floats Array:", random_floats)
print("Items Less Than Mean:", less_than_mean)
print("Items Less Than Mean - Std:", less_than_mean_minus_std)

import numpy as np

# (1) Create a NumPy array of 10 random integers from 0-100
random_integers = np.random.randint(0, 101, 10)

# (2) Calculate the mean
mean = np.mean(random_integers)

# (3) Create an array of type float and replace outliers with the mean
std = np.std(random_integers)
outliers = np.logical_or(random_integers < (mean - std), random_integers > (mean + std))
float_array = random_integers.astype(float)
float_array[outliers] = mean

# (4) Create a NumPy array of 20 random floats from 0-100
random_floats = np.random.uniform(0, 100, 20)

# (5) Replace numbers with even integer portions with the mean
integer_portion = np.floor(random_floats)
even_integer_mask = (integer_portion % 2 == 0)
random_floats[even_integer_mask] = mean

# Print the results
print("(1) Random Integers Array:", random_integers)
print("(2) Mean of Random Integers:", mean)
print("(3) Float Array with Outliers Replaced:", float_array)
print("(4) Random Floats Array:", random_floats)

import numpy as np

# (1) Create a 2-dimensional NumPy array of 45 random integers from 0-100
random_integers_2d = np.random.randint(0, 101, size=(9, 5))

# (2) Retrieve the elements at row index 2
row_2_elements = random_integers_2d[2, :]

# (3) Retrieve the elements at column index 3
column_3_elements = random_integers_2d[:, 3]

# (4) Retrieve the elements at row indexes 1 and 4
rows_1_and_4_elements = random_integers_2d[[1, 4], :]

# (5) Retrieve the elements at column indexes 1 and 4
columns_1_and_4_elements = random_integers_2d[:, [1, 4]]

# (6) Get the mean of the even numbers in row index 4
row_4_even_numbers = random_integers_2d[4, random_integers_2d[4, :] % 2 == 0]
mean_row_4_even = np.mean(row_4_even_numbers)

# (7) Get the mean of the odd numbers in column index 4
column_4_odd_numbers = random_integers_2d[random_integers_2d[:, 4] % 2 != 0, 4]
mean_column_4_odd = np.mean(column_4_odd_numbers)

# Print the results
print("(1) 2D Array of Random Integers:\n", random_integers_2d)
print("(2) Elements at Row Index 2:", row_2_elements)
print("(3) Elements at Column Index 3:", column_3_elements)
print("(4) Elements at Row Indexes 1 and 4:\n", rows_1_and_4_elements)
print("(5) Elements at Column Indexes 1 and 4:\n", columns_1_and_4_elements)
print("(6) Mean of Even Numbers in Row Index 4:", mean_row_4_even)
print("(7) Mean of Odd Numbers in Column Index 4:", mean_column_4_odd)

import numpy as np

# Create 10 random 1D arrays of size 10
arrays = [np.random.rand(10) for _ in range(10)]

# Stack them together into a 2D array
stacked_array = np.vstack(arrays)

# Normalize the data (rescale to [0, 1])
normalized_array = (stacked_array - stacked_array.min()) / (stacked_array.max() - stacked_array.min())

# Reshape the 2D array back into a 1D array
reshaped_array = normalized_array.flatten()

# Print the results
print("Stacked 2D Array:\n", stacked_array)
print("Normalized 2D Array:\n", normalized_array)
print("Reshaped 1D Array:\n", reshaped_array)

import numpy as np

# Create two 2D NumPy matrices
matrix1 = np.array([[10, 20], [30, 40]])  # 2x2 matrix
matrix2 = np.array([[50, 60], [70, 80]])  # 2x2 matrix

# Check if the dimensions are suitable for multiplication
if matrix1.shape[1] != matrix2.shape[0]:
    print("Matrix dimensions are not suitable for multiplication.")
else:
    # Perform matrix multiplication
    result = np.dot(matrix1, matrix2)
    # Alternatively, you can also use the @ operator for matrix multiplication:
    # result = matrix1 @ matrix2

    # Print the result
    print("Matrix 1:")
    print(matrix1)
    print("Matrix 2:")
    print(matrix2)
    print("Result of Matrix Multiplication:")
    print(result)

import numpy as np

# Define the two vectors as NumPy arrays
A = np.array([1, 2, 3, 4])
B = np.array([5, 6, 7, 8])

# Calculate the dot product using np.dot() function
dot_product = np.dot(A, B)

# Calculate the cross product using np.cross() function
cross_product = np.cross(A[:3], B[:3])

# Print the dot product and cross product
print("Dot Product of A and B:", dot_product)
print("Cross Product of A and B:", cross_product)

import numpy as np

M1 = np.array([[1, 2, 3], [4, 5, 6]])
transposed_matrix = np.transpose(M1)
print(transposed_matrix)

#A
M1 = np.array([[1, 2, 3], [4, 5, 6]])
transposed_matrix = M1.T
print(transposed_matrix)

#B
M2 = np.array([[2, 0, -1], [5, 1, 0], [0, 1, 3]])
inverse_matrix = np.linalg.inv(M2)
print(inverse_matrix)

import numpy as np

# Define the matrix Z
Z = np.array([[-4, -7], [1, 4]])

# Perform Singular Value Decomposition (SVD)
U, S, VT = np.linalg.svd(Z)

# U: Left singular vectors
# S: Singular values (sorted in descending order)
# VT: Right singular vectors (transposed)

print("U (Left Singular Vectors):")
print(U)
print("\nS (Singular Values):")
print(S)
print("\nVT (Right Singular Vectors Transposed):")
print(VT)

import matplotlib.pyplot as plt

# Generate x values (angles)
x = np.linspace(0, 2 * np.pi, 100)

# Calculate sine and cosine values
sin_values = np.sin(x)
cos_values = np.cos(x)

# Plot both sine and cosine on the same graph
plt.figure(figsize=(8, 4))
plt.plot(x, sin_values, label='sin(x)', color='blue')
plt.plot(x, cos_values, label='cos(x)', color='red')

# Set axis limits
plt.xlim(0, 2 * np.pi)
plt.ylim(-1.2, 1.2)

# Add title and legend
plt.title('Sine and Cosine Waves')
plt.legend()

# Annotate some points on the plot
plt.annotate('Maxima', xy=(np.pi / 2, 1), xytext=(np.pi / 2 + 0.5, 1.1),
             arrowprops=dict(arrowstyle='->', lw=1.5),
             fontsize=10, color='blue')
plt.annotate('Minima', xy=(3 * np.pi / 2, -1), xytext=(3 * np.pi / 2 + 0.5, -1.1),
             arrowprops=dict(arrowstyle='->', lw=1.5),
             fontsize=10, color='red')

# Show the combined plot
plt.show()

# Plot sine and cosine separately using subplots
plt.figure(figsize=(12, 4))

# Sine subplot
plt.subplot(1, 2, 1)
plt.plot(x, sin_values, label='sin(x)', color='blue')
plt.title('Sine Wave')
plt.xlabel('x')
plt.ylabel('sin(x)')
plt.legend()

# Cosine subplot
plt.subplot(1, 2, 2)
plt.plot(x, cos_values, label='cos(x)', color='red')
plt.title('Cosine Wave')
plt.xlabel('x')
plt.ylabel('cos(x)')
plt.legend()

# Show the subplots
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
array1 = np.random.rand(1024)
array2 = np.random.rand(1024)
plt.figure(figsize=(9, 3))
plt.scatter(array1, array2, s=10, c='b', marker='o', alpha=0.5)
plt.xlabel('Array 1')
plt.ylabel('Array 2')
plt.title('Scatter Plot of Random Data')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x, y):
    return (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)
x = np.linspace(-3, 3, 100)
y = np.linspace(-3, 3, 100)
X, Y = np.meshgrid(x, y)
Z = f(X, Y)

plt.figure(figsize=(8, 6))
contour = plt.contour(X, Y, Z, levels=20, cmap='viridis')
plt.colorbar(contour, label='f(x, y)')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Contour Plot of f(x, y)')


plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Create a grid of points in 3D space
x = np.linspace(-3, 3, 100)
y = np.linspace(-3, 3, 100)
X, Y = np.meshgrid(x, y)

# Define the Gaussian function in 3D
def gaussian(x, y):
    return np.exp(-(x**2 + y**2) / 2) / (2 * np.pi)

Z = gaussian(X, Y)

# Create a 3D plot
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

# Plot the 3D Gaussian surface
surface = ax.plot_surface(X, Y, Z, cmap='viridis')

# Add labels and a title
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('3D Gaussian Plot')

# Add a color bar
fig.colorbar(surface, label='Gaussian Value')

# Show the 3D plot
plt.show()

from scipy.integrate import quad
import numpy as np

# Define the Gaussian function
gaussian = lambda x: np.exp(-x**2)

# Define the integration limits
a = 0
b = 1

# Use the quad method to perform the integration
result, error = quad(gaussian, a, b)

# Print the result and error
print("Result of Integration:", result)
print("Estimated Error:", error)

import numpy as np
from scipy import interpolate
import matplotlib.pyplot as plt

# Generate the data
x = np.linspace(0, 5, 10)
y = np.cos(x**2/3 + 4)

# Create a finer grid for plotting the interpolation
x_interp = np.linspace(0, 5, 100)

# Linear interpolation
linear_interp = interpolate.interp1d(x, y, kind='linear')
y_linear = linear_interp(x_interp)

# Cubic interpolation
cubic_interp = interpolate.interp1d(x, y, kind='cubic')
y_cubic = cubic_interp(x_interp)

# Plot the original data
plt.figure(figsize=(10, 6))
plt.plot(x, y, 'ro', label='Data')

# Plot the linear interpolation
plt.plot(x_interp, y_linear, 'b-', label='Linear Interpolation')

# Plot the cubic interpolation
plt.plot(x_interp, y_cubic, 'g--', label='Cubic Interpolation')

plt.xlabel('X')
plt.ylabel('Y')
plt.title('Linear and Cubic Interpolation')
plt.legend()
plt.grid(True)
plt.show()